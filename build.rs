use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use toml::{Table, Value};

const GENERATED_FILE_NAME: &str = "calmui_i18n_generated.rs";
const DEFAULT_I18N_REL_PATH: &str = "locales.toml";
const DEFAULT_LOCALE: &str = "en-US";

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-env-changed=CALMUI_I18N_TOML");
    println!("cargo:rerun-if-env-changed=CALMUI_I18N_APP_ROOT");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR is required"));
    let generated_path = out_dir.join(GENERATED_FILE_NAME);

    if env::var_os("CARGO_FEATURE_I18N").is_none() {
        write_stub_catalog(&generated_path).expect("failed to write i18n stub catalog");
        return;
    }

    let source_path =
        resolve_catalog_path(&out_dir).unwrap_or_else(|message| panic!("calmui i18n: {message}"));
    println!("cargo:rerun-if-changed={}", source_path.display());

    let source = fs::read_to_string(&source_path).unwrap_or_else(|err| {
        panic!(
            "calmui i18n: failed to read {}: {err}",
            source_path.display()
        )
    });

    let catalog = parse_catalog(&source, &source_path)
        .unwrap_or_else(|message| panic!("calmui i18n: {message}"));
    let rendered = render_catalog(&catalog);

    fs::write(&generated_path, rendered).unwrap_or_else(|err| {
        panic!(
            "calmui i18n: failed to write generated catalog {}: {err}",
            generated_path.display()
        )
    });
}

fn resolve_catalog_path(out_dir: &Path) -> Result<PathBuf, String> {
    if let Some(explicit_path) = env::var_os("CALMUI_I18N_TOML") {
        let candidate = PathBuf::from(explicit_path);
        if candidate.exists() {
            return Ok(candidate);
        }
        return Err(format!(
            "explicit path from CALMUI_I18N_TOML not found: {}",
            candidate.display()
        ));
    }

    let app_root = if let Some(explicit_root) = env::var_os("CALMUI_I18N_APP_ROOT") {
        PathBuf::from(explicit_root)
    } else {
        infer_app_root_from_out_dir(out_dir).ok_or_else(|| {
            format!(
                "cannot infer app root from OUT_DIR={}, set CALMUI_I18N_APP_ROOT or CALMUI_I18N_TOML explicitly",
                out_dir.display()
            )
        })?
    };

    let primary = app_root.join(DEFAULT_I18N_REL_PATH);
    println!("cargo:rerun-if-changed={}", primary.display());
    if primary.exists() {
        return Ok(primary);
    }

    Err(format!(
        "i18n feature requires translation file at {} or set CALMUI_I18N_TOML",
        primary.display()
    ))
}

fn infer_app_root_from_out_dir(out_dir: &Path) -> Option<PathBuf> {
    let mut current = Some(out_dir);
    while let Some(path) = current {
        if path.file_name().and_then(|name| name.to_str()) == Some("target") {
            return path.parent().map(Path::to_path_buf);
        }
        current = path.parent();
    }
    None
}

fn write_stub_catalog(path: &Path) -> std::io::Result<()> {
    fs::write(
        path,
        r#"// @generated by calmui/build.rs
pub(super) const DEFAULT_LOCALE: &str = "en-US";
pub(super) static LOCALES: &[(&str, &[(&str, &str)])] = &[("en-US", &[])];
"#,
    )
}

struct Catalog {
    default_locale: String,
    locales: BTreeMap<String, BTreeMap<String, String>>,
}

fn parse_catalog(content: &str, path: &Path) -> Result<Catalog, String> {
    let root = content
        .parse::<Value>()
        .map_err(|err| format!("failed to parse {} as TOML: {err}", path.to_string_lossy()))?;
    let root_table = root
        .as_table()
        .ok_or_else(|| format!("{} must contain a top-level table", path.to_string_lossy()))?;

    let default_locale = root_table
        .get("default_locale")
        .and_then(Value::as_str)
        .unwrap_or(DEFAULT_LOCALE)
        .trim();
    let default_locale = canonicalize_locale_tag(default_locale).ok_or_else(|| {
        "`default_locale` must be a valid locale tag in BCP-47 style (for example `en-US`)"
            .to_string()
    })?;

    let locales_root = root_table
        .get("locales")
        .ok_or_else(|| "`locales` table is required".to_string())?
        .as_table()
        .ok_or_else(|| "`locales` must be a TOML table".to_string())?;
    if locales_root.is_empty() {
        return Err("`locales` table must not be empty".to_string());
    }

    let mut by_key = BTreeMap::new();
    collect_key_entries(locales_root, "", &mut by_key)?;

    let mut locales: BTreeMap<String, BTreeMap<String, String>> = BTreeMap::new();
    for (key, translations) in by_key {
        for (locale, text) in translations {
            locales.entry(locale).or_default().insert(key.clone(), text);
        }
    }

    if !locales.contains_key(&default_locale) {
        return Err(format!(
            "default_locale `{default_locale}` is missing in [locales]"
        ));
    }

    Ok(Catalog {
        default_locale,
        locales,
    })
}

fn collect_key_entries(
    table: &Table,
    prefix: &str,
    entries: &mut BTreeMap<String, BTreeMap<String, String>>,
) -> Result<(), String> {
    for (segment, value) in table {
        let key = if prefix.is_empty() {
            segment.to_string()
        } else {
            format!("{prefix}.{segment}")
        };

        let nested = value
            .as_table()
            .ok_or_else(|| format!("translation key `{key}` must map to a TOML table"))?;

        let all_strings = nested.values().all(Value::is_str);
        let all_tables = nested.values().all(Value::is_table);

        if all_strings {
            let mut translated = BTreeMap::new();
            for (locale_tag, text_value) in nested {
                let locale = canonicalize_locale_tag(locale_tag).ok_or_else(|| {
                    format!(
                        "translation key `{key}` has invalid locale tag `{locale_tag}`; use BCP-47 style tags such as `en-US`"
                    )
                })?;
                let text = text_value.as_str().expect("checked as string").to_string();
                if translated.insert(locale.clone(), text).is_some() {
                    return Err(format!(
                        "translation key `{key}` has duplicate locale after canonicalization: `{locale}`"
                    ));
                }
            }

            if translated.is_empty() {
                return Err(format!(
                    "translation key `{key}` must contain at least one locale translation"
                ));
            }
            if entries.insert(key.clone(), translated).is_some() {
                return Err(format!("duplicate translation key `{key}`"));
            }
            continue;
        }

        if all_tables {
            collect_key_entries(nested, &key, entries)?;
            continue;
        }

        return Err(format!(
            "translation key `{key}` must be either a locale map table or nested key tables"
        ));
    }
    Ok(())
}

fn canonicalize_locale_tag(raw: &str) -> Option<String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return None;
    }

    let parts = trimmed.split('-').map(str::trim).collect::<Vec<_>>();
    if parts.iter().any(|part| part.is_empty()) {
        return None;
    }

    let language = parts.first()?;
    if !(2..=3).contains(&language.len()) || !language.chars().all(|ch| ch.is_ascii_alphabetic()) {
        return None;
    }

    let mut canonical = Vec::with_capacity(parts.len());
    canonical.push(language.to_ascii_lowercase());

    for segment in parts.iter().skip(1) {
        if !(2..=8).contains(&segment.len())
            || !segment.chars().all(|ch| ch.is_ascii_alphanumeric())
        {
            return None;
        }

        if segment.len() == 2 && segment.chars().all(|ch| ch.is_ascii_alphabetic()) {
            canonical.push(segment.to_ascii_uppercase());
        } else if segment.len() == 4 && segment.chars().all(|ch| ch.is_ascii_alphabetic()) {
            let mut chars = segment.chars();
            let first = chars
                .next()
                .map(|ch| ch.to_ascii_uppercase())
                .unwrap_or_default();
            let rest = chars.as_str().to_ascii_lowercase();
            canonical.push(format!("{first}{rest}"));
        } else {
            canonical.push(segment.to_ascii_lowercase());
        }
    }

    Some(canonical.join("-"))
}

fn render_catalog(catalog: &Catalog) -> String {
    let mut output = String::new();
    output.push_str("// @generated by calmui/build.rs\n");
    output.push_str("pub(super) const DEFAULT_LOCALE: &str = ");
    output.push_str(&quote(&catalog.default_locale));
    output.push_str(";\n");
    output.push_str("pub(super) static LOCALES: &[(&str, &[(&str, &str)])] = &[\n");

    for (locale, entries) in &catalog.locales {
        output.push_str("    (");
        output.push_str(&quote(locale));
        output.push_str(", &[\n");
        for (key, value) in entries {
            output.push_str("        (");
            output.push_str(&quote(key));
            output.push_str(", ");
            output.push_str(&quote(value));
            output.push_str("),\n");
        }
        output.push_str("    ]),\n");
    }

    output.push_str("];\n");
    output
}

fn quote(value: &str) -> String {
    format!("{value:?}")
}
